<!-- The HTML and CSS parts of index.html remain the same. -->
<!-- Replace the entire <script> tag with the following: -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    // --- D3 selections and initial setup (mostly unchanged) ---
    const mainTitle = d3.select("#main-title");
    const inputContainer = d3.select("#input-container");
    const wordForm = d3.select("#word-form");
    const scanner = d3.select("#radar-scanner");
    const tooltip = d3.select(".tooltip");
    const legend = d3.select("#legend");
    const senseSelector = d3.select("#sense-selector");
    const restartBtn = d3.select("#restart-btn");
    const exportBtn = d3.select("#export-btn");
    
    const container = d3.select("#chart-container");
    const containerRect = container.node().getBoundingClientRect();
    const width = containerRect.width;
    const height = containerRect.height;
    
    const isMobile = window.innerWidth <= 768;
    const margin = isMobile ? 65 : 100;
    const maxRadius = (Math.min(width, height) / 2) - margin;
    
    const svg = container.append("svg").attr("width", width).attr("height", height).attr("viewBox", `0 0 ${width} ${height}`).attr("preserveAspectRatio", "xMidYMid meet")
        .on("click", (event) => {
            if (selectedWords.length > 0) { clearComparison(); } 
            else if (currentView !== 'radar') { event.stopPropagation(); switchToRadarView(); }
        });
    const chartGroup = svg.append("g").attr("transform", `translate(${width / 2}, ${height / 2})`);

    // --- MODIFIED STATE AND SCALES ---
    let currentView = 'radar', activeSpectrumAxis = null, currentBubbles = null, currentClineBubbles = null, selectedWords = [], isSoundOn = true, currentRadarData = null;

    const difficultyColors = { 'beginner': '#4CAF50', 'intermediate': '#FF9800', 'advanced': '#F44336' };
    const antonymColor = '#9467bd'; // A distinct color for opposites

    const bubbleSizeScale = d3.scaleSqrt().domain([0, 100]).range(isMobile ? [5, 20] : [8, 30]);
    const scoreToPixelScale = d3.scaleLinear().domain([-1, 1]).range([-maxRadius, maxRadius]).clamp(true);
    
    const largestBubbleRadius = bubbleSizeScale.range()[1];
    const spectrumRange = maxRadius * 0.75;
    const spectrumScale = d3.scaleLinear().domain([-1, 1]).range([-spectrumRange + largestBubbleRadius, spectrumRange - largestBubbleRadius]).clamp(true);

    const radarBgGroup = chartGroup.append("g").attr("class", "radar-background");
    const spectrumGroup = chartGroup.append("g").attr("class", "spectrum-view").style("opacity", 0).attr("pointer-events", "none");
    const bubblesGroup = chartGroup.append("g").attr("class", "bubbles-container");
    const clineBubblesGroup = chartGroup.append("g").attr("class", "cline-bubbles-container");
    const labelsGroup = chartGroup.append("g").attr("class", "labels-container");
    
    const submitBtn = d3.select("#submit-btn");
    let currentSearch = { word: '', partOfSpeech: '', category: '' };
    
    drawRadarBackground();
    drawSpectrumView();
    
    // --- Event listeners (unchanged) ---
    wordForm.on("submit", handleFormSubmit);
    submitBtn.on("click", (event) => { event.preventDefault(); handleFormSubmit(event); });
    d3.selectAll('#category-input, #custom-words-input').on('keydown', function(event) { if (event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); handleFormSubmit(event); }});
    d3.select('#word-input').on('input', updateSubmitButtonState);
    d3.selectAll('.pos-option').on('click', function() { d3.selectAll('.pos-option').classed('selected', false); d3.select(this).classed('selected', true); updateSubmitButtonState(); });
    mainTitle.on("click", resetToInitialState);
    setupSoundToggle();
    restartBtn.on("click", resetToInitialState);
    exportBtn.on("click", exportAsPNG);

    // --- Form handling and data fetching (unchanged, but now receives new data structure) ---
    // ... [ The functions updateSubmitButtonState, handleFormSubmit, handleSenseSelection are functionally the same ] ...
    function updateSubmitButtonState() { const word = d3.select("#word-input").property("value").trim(); const posSelected = d3.select(".pos-option.selected").node(); if (word && posSelected) { submitBtn.classed("hidden", false); } else { submitBtn.classed("hidden", true); } }
    async function handleFormSubmit(event) {
        event.preventDefault();
        currentSearch.word = d3.select("#word-input").property("value").trim();
        const selectedPosNode = d3.select(".pos-option.selected").node();
        currentSearch.category = d3.select("#category-input").property("value").trim();
        const customWords = d3.select("#custom-words-input").property("value").trim();
        if (!currentSearch.word) { alert("Please enter a word."); return; }
        if (!selectedPosNode) { alert("Please select a part of speech."); return; }
        currentSearch.partOfSpeech = selectedPosNode.dataset.pos;
        if (currentView !== 'radar') { await switchToRadarView(); }
        inputContainer.classed("hidden", true);
        legend.classed("hidden", true);
        clearChart();
        if (customWords) { const synonyms = customWords.split(',').map(s => s.trim()).filter(Boolean); if (synonyms.length > 0) { handleSenseSelection(synonyms); return; } }
        mainTitle.style("cursor", "default").text(`Discovering meanings for "${currentSearch.word}"...`);
        scanner.classed("hidden", false);
        const discoveryData = await fetchWordData(currentSearch.word, currentSearch.partOfSpeech, currentSearch.category);
        if (discoveryData && discoveryData.senses) {
            scanner.classed("hidden", true);
            mainTitle.text("Please select a meaning to explore");
            senseSelector.select("#sense-title").text(`Which meaning of "${currentSearch.word}"?`);
            senseSelector.select("#sense-options").selectAll("*").remove();
            const primaryOptions = senseSelector.select("#sense-options").selectAll(".primary-sense").data(discoveryData.senses);
            primaryOptions.enter().append("button").attr("class", "sense-option-btn primary-sense").text(d => `"${d.synonyms.slice(0, 3).join('", "')}" ${d.synonyms.length > 3 ? `(+${d.synonyms.length - 3} more)` : ''} — ${d.definition}`).on("click", (e, d) => handleSenseSelection(d.synonyms));
            if (discoveryData.hasMore && discoveryData.additionalSenses) {
                const showMoreContainer = senseSelector.select("#sense-options").append("div").attr("id", "show-more-container");
                showMoreContainer.append("div").attr("id", "show-more-btn").text(`+ Show ${discoveryData.additionalSenses.length} more specific meanings`).on("click", function() { const additionalContainer = d3.select("#additional-senses"); const isExpanded = additionalContainer.classed("expanded"); additionalContainer.classed("expanded", !isExpanded); d3.select(this).text(isExpanded ? `+ Show ${discoveryData.additionalSenses.length} more specific meanings` : "− Show fewer meanings"); });
                showMoreContainer.append("div").attr("class", "sense-divider");
                const additionalContainer = showMoreContainer.append("div").attr("id", "additional-senses").attr("class", "additional-senses");
                const additionalOptions = additionalContainer.selectAll(".additional-sense").data(discoveryData.additionalSenses);
                additionalOptions.enter().append("button").attr("class", "sense-option-btn additional-sense").style("opacity", "0.8").style("font-size", "clamp(13px, 3vw, 15px)").text(d => `"${d.synonyms.slice(0, 2).join('", "')}" ${d.synonyms.length > 2 ? `(+${d.synonyms.length - 2})` : ''} — ${d.definition}`).on("click", (e, d) => handleSenseSelection(d.synonyms));
            }
            senseSelector.classed("hidden", false);
        } else if (discoveryData && discoveryData.synonyms) {
            processAndDrawRadar(discoveryData);
        } else {
            scanner.classed("hidden", true);
            mainTitle.text(discoveryData.error || `No data for "${currentSearch.word}". Click to try again.`).style("cursor", "pointer");
            restartBtn.classed("hidden", false);
        }
    }
    async function handleSenseSelection(synonyms) {
        senseSelector.classed("hidden", true);
        mainTitle.style("cursor", "default").text(`Generating Radar for "${currentSearch.word}"...`);
        scanner.classed("hidden", false);
        const wordData = await fetchWordData(currentSearch.word, currentSearch.partOfSpeech, currentSearch.category, synonyms);
        if (wordData && wordData.synonyms) {
            processAndDrawRadar(wordData);
        } else {
            scanner.classed("hidden", true);
            mainTitle.text(wordData.error || `No data for "${currentSearch.word}". Click to try again.`).style("cursor", "pointer");
            restartBtn.classed("hidden", false);
        }
    }

    // --- MODIFIED --- Main drawing function
    function processAndDrawRadar(wordData) {
        scanner.classed("hidden", true);
        currentRadarData = wordData;
        mainTitle.text(`Word Radar: "${wordData.hub_word}"`).style("cursor", "pointer");
        
        updateLegend();
        drawRadarBackground(wordData.axes);
        drawWordBubbles(wordData);
        
        legend.classed("hidden", false);
        restartBtn.classed("hidden", false);
        exportBtn.classed("hidden", false);
    }
    
    function clearChart() {
        clearComparison();
        if (currentBubbles) currentBubbles.remove();
        if (currentClineBubbles) currentClineBubbles.remove();
        labelsGroup.selectAll(".quadrant-label, .antonym-label").remove();
        d3.select("#legend-items-container").selectAll("*").remove(); 
    }
    
    // --- MODIFIED --- Draw fixed axes and antonyms
    function drawWordBubbles(radarData) {
        // 1. Draw Static Axis Labels
        const labelOffset = maxRadius + (isMobile ? 15 : 25);
        labelsGroup.append("text").attr("class", "quadrant-label").attr("x", 0).attr("y", -labelOffset).attr("text-anchor", "middle").text("FORMALITY").on("click", e => toggleSpectrumView('formality', radarData.axes.y));
        labelsGroup.append("text").attr("class", "quadrant-label").attr("x", labelOffset).attr("y", 0).attr("dominant-baseline", "middle").attr("text-anchor", "start").text("STYLE").on("click", e => toggleSpectrumView('style', radarData.axes.x));
        
        // 2. Position and draw synonym bubbles
        const synonymNodes = radarData.synonyms.map(d => {
            d.x = scoreToPixelScale(d.style);
            d.y = -scoreToPixelScale(d.formality); // Y is inverted in SVG
            d.isAntonym = false;
            return d;
        });
        
        const simulation = d3.forceSimulation(synonymNodes)
            .force("collide", d3.forceCollide(d => bubbleSizeScale(d.frequency) + 3).strength(0.9))
            .force("x", d3.forceX(d => d.x).strength(0.2))
            .force("y", d3.forceY(d => d.y).strength(0.2))
            .stop();
        for (let i = 0; i < 150; ++i) simulation.tick();
        
        // Save final radar positions for transitions
        synonymNodes.forEach(d => { d.radarX = d.x; d.radarY = d.y; });
        
        // 3. Position and draw antonym bubbles outside the radar
        const antonymRadius = maxRadius * 1.08;
        const angleStep = (Math.PI / 2) / (radarData.antonyms.length + 1);
        const antonymNodes = radarData.antonyms.map((d, i) => {
            const angle = (3 * Math.PI / 4) + ((i+1) * angleStep) - (Math.PI / 4); // Place in bottom-left/top-right corners
            const corner = Math.floor(i / (radarData.antonyms.length/2)); // 0 for top-right, 1 for bottom-left
            const signX = corner === 0 ? 1 : -1;
            const signY = corner === 0 ? -1 : 1;
            d.x = signX * antonymRadius * Math.cos(angleStep * (i % (radarData.antonyms.length/2) + 1));
            d.y = signY * antonymRadius * Math.sin(angleStep * (i % (radarData.antonyms.length/2) + 1));
            d.isAntonym = true;
            d.frequency = 50; // Give them a medium, consistent size
            d.difficulty = 'intermediate'; // For color and tooltip
            d.definition = 'An opposite of the main word.';
            d.example = `Click to see a scale from '${d.term}' to '${radarData.hub_word}'.`;
            return d;
        });
        
        const allNodes = [...synonymNodes, ...antonymNodes];

        currentBubbles = bubblesGroup.selectAll(".word-bubble")
            .data(allNodes, d => d.term)
            .enter().append("g")
            .attr("class", "word-bubble");

        currentBubbles.attr("transform", d => `translate(${d.x}, ${d.y})`);
        
        currentBubbles.append("circle")
            .attr("r", 0)
            .style("fill", d => d.isAntonym ? antonymColor : difficultyColors[d.difficulty] || '#cccccc')
            .transition().duration(500).delay((d,i) => i * 20)
            .attr("r", d => bubbleSizeScale(d.frequency));
            
        currentBubbles.append("text")
            .text(d => d.term)
            .attr("dy", "0.3em").style("opacity", 0)
            .transition().duration(500).delay((d,i) => i * 20)
            .style("opacity", 1);
            
        setupTooltipEvents(currentBubbles);
    }
    
    // --- MODIFIED --- View switching logic
    function toggleSpectrumView(axisKey, axisData) {
        clearComparison();
        if (currentView === 'spectrum' && activeSpectrumAxis === axisKey) {
            switchToRadarView();
        } else {
            switchToSpectrumView(axisKey, axisData);
        }
    }
    
    function switchToSpectrumView(axisKey, axisData) {
        if (currentClineBubbles) currentClineBubbles.style("opacity", 0).attr("pointer-events", "none");

        currentView = 'spectrum'; 
        activeSpectrumAxis = axisKey;
        mainTitle.text(`Spectrum: ${axisData.name}`);
        spectrumGroup.select(".spectrum-label-left").text(axisData.labels[0].toUpperCase());
        spectrumGroup.select(".spectrum-label-right").text(axisData.labels[1].toUpperCase());
        
        labelsGroup.transition().duration(500).style("opacity", 0).attr("pointer-events", "none");
        radarBgGroup.selectAll(".radar-ring, .quadrant-line").transition().duration(300).style("opacity", 0);
        spectrumGroup.transition().delay(200).duration(500).style("opacity", 1).attr("pointer-events", "auto");
        
        const allNodes = currentBubbles.data().filter(d => !d.isAntonym); // Only show synonyms on spectrum
        
        const spectrumSimulation = d3.forceSimulation(allNodes)
            .force("x", d3.forceX(d => spectrumScale(d[axisKey])).strength(1))
            .force("y", d3.forceY(0).strength(0.05))
            .force("collide", d3.forceCollide(d => bubbleSizeScale(d.frequency) + 3).strength(0.8))
            .stop();
        for (let i = 0; i < 150; ++i) spectrumSimulation.tick();
        
        currentBubbles.filter(d => d.isAntonym).transition().duration(750).style("opacity", 0).attr("pointer-events", "none");
        currentBubbles.filter(d => !d.isAntonym).transition().duration(750).ease(d3.easeCubicOut).style("opacity", 1).attr("pointer-events", "auto").attr("transform", d => `translate(${d.x}, ${d.y})`);
    }

    async function showClineForAntonym() {
        currentView = 'cline-spectrum';
        activeSpectrumAxis = null;
        
        mainTitle.text(`Generating Cline for "${currentRadarData.hub_word}"...`);
        scanner.classed("hidden", false);
        
        if (currentBubbles) currentBubbles.style("pointer-events", "none").transition().duration(300).style("opacity", 0);
        labelsGroup.transition().duration(500).style("opacity", 0).attr("pointer-events", "none");
        radarBgGroup.selectAll(".radar-ring, .quadrant-line").transition().duration(300).style("opacity", 0);
        
        const clineData = await fetchClineData(currentRadarData.hub_word, currentRadarData.part_of_speech);
        scanner.classed("hidden", true);

        if (!clineData || clineData.error) {
            mainTitle.text(clineData.error || `Could not generate cline. Click to return.`);
            return;
        }

        mainTitle.text(`Cline: ${clineData.spectrumLabels[0]} ↔ ${clineData.spectrumLabels[1]}`);
        spectrumGroup.select(".spectrum-label-left").text(clineData.spectrumLabels[0].toUpperCase());
        spectrumGroup.select(".spectrum-label-right").text(clineData.spectrumLabels[1].toUpperCase());
        spectrumGroup.transition().delay(200).duration(500).style("opacity", 1).attr("pointer-events", "auto");
        
        drawClineBubbles(clineData);
    }
    
    // --- UNCHANGED, BUT CALLED BY NEW LOGIC ---
    function drawClineBubbles(clineData) {
        if (currentClineBubbles) currentClineBubbles.remove();
        const nodes = clineData.words.map(d => {
            d.x = spectrumScale(d.intensity);
            d.y = (Math.random() - 0.5) * 50; 
            return d;
        });
        const simulation = d3.forceSimulation(nodes)
            .force("x", d3.forceX(d => spectrumScale(d.intensity)).strength(1))
            .force("y", d3.forceY(0).strength(0.1))
            .force("collide", d3.forceCollide(d => bubbleSizeScale(d.frequency) + 3).strength(0.9)).stop();
        for (let i = 0; i < 150; ++i) simulation.tick();
        
        currentClineBubbles = clineBubblesGroup.selectAll(".word-bubble").data(nodes, d => d.term).enter().append("g").attr("class", "word-bubble");
        currentClineBubbles.attr("transform", d => `translate(${d.x}, ${d.y})`);
        currentClineBubbles.append("circle").attr("r", 0).style("fill", d => d.intensity < 0 ? antonymColor : difficultyColors.beginner)
            .transition().duration(500).delay((d,i) => i * 30).attr("r", d => bubbleSizeScale(d.frequency));
        currentClineBubbles.append("text").text(d => d.term).attr("dy", "0.3em").style("opacity", 0)
            .transition().duration(500).delay((d,i) => i * 30).style("opacity", 1);
        setupTooltipEvents(currentClineBubbles);
    }

    // --- MODIFIED --- Switch back to radar view
    function switchToRadarView() {
        return new Promise(resolve => {
            if (currentView === 'radar' && activeSpectrumAxis === null) { resolve(); return; }
            clearComparison(); 
            
            if (currentClineBubbles) {
                currentClineBubbles.transition().duration(300).style("opacity", 0).attr("pointer-events", "none").end().then(() => {
                    currentClineBubbles.remove(); currentClineBubbles = null;
                });
            }
            
            currentView = 'radar'; activeSpectrumAxis = null;
            if(currentRadarData) mainTitle.text(`Word Radar: "${currentRadarData.hub_word}"`);
            
            legend.style("opacity", 1);
            spectrumGroup.transition().duration(500).style("opacity", 0).attr("pointer-events", "none");
            radarBgGroup.selectAll(".quadrant-line, .radar-ring").transition().delay(200).duration(500).style("opacity", 1);
            labelsGroup.selectAll(".quadrant-label").classed("active", false);
            labelsGroup.transition().delay(200).duration(500).style("opacity", 1).attr("pointer-events", "auto");
            
            if (currentBubbles) {
                currentBubbles.transition().duration(750).ease(d3.easeCubicOut)
                    .style("opacity", 1).attr("pointer-events", "auto")
                    .attr("transform", d => `translate(${d.isAntonym ? d.x : d.radarX}, ${d.isAntonym ? d.y : d.radarY})`)
                    .end().then(resolve);
            } else { resolve(); }
        });
    }
    
    // --- MODIFIED --- Event handler for word clicks
    function handleWordClick(event, d) {
        event.stopPropagation();
        
        // If an antonym is clicked, trigger cline generation
        if (d.isAntonym) {
            showClineForAntonym(d);
            return;
        }

        tooltip.style("opacity", 0);
        const node = d3.select(event.currentTarget.parentNode);
        const isSelected = selectedWords.some(sw => sw.term === d.term);
        if (isSelected) {
            selectedWords = selectedWords.filter(sw => sw.term !== d.term);
            node.classed("selected", false);
        } else {
            if (selectedWords.length < 2) {
                selectedWords.push(d);
                node.classed("selected", true);
            }
        }
        
        const activeBubbles = currentView === 'cline-spectrum' ? currentClineBubbles : currentBubbles;
        if (selectedWords.length === 2) {
            showComparisonTooltip(selectedWords[0], selectedWords[1]);
            activeBubbles.classed("dimmed", data => !selectedWords.some(sw => sw.term === data.term));
        } else {
            tooltip.classed("comparison-tooltip", false);
            if (activeBubbles) activeBubbles.classed("dimmed", false);
        }
    }
    
    // --- MODIFIED --- Update legend for difficulty
    function updateLegend() {
        const legendItemsContainer = d3.select("#legend-items-container");
        legendItemsContainer.selectAll("*").remove();
        
        const difficultyData = [
            { label: 'Beginner', color: difficultyColors.beginner },
            { label: 'Intermediate', color: difficultyColors.intermediate },
            { label: 'Advanced', color: difficultyColors.advanced },
            { label: 'Opposite', color: antonymColor }
        ];

        const legendItems = legendItemsContainer.selectAll(".legend-item")
            .data(difficultyData).enter().append("div").attr("class", "legend-item");
        legendItems.append("div").attr("class", "legend-circle").style("background-color", d => d.color);
        legendItems.append("span").text(d => d.label);
    }

    // --- All other helper functions remain the same ---
    async function fetchClineData(word, partOfSpeech) { try { const response = await fetch('/.netlify/functions/word-radar-data', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ word, partOfSpeech, requestType: 'cline' }) }); if (!response.ok) { const errorData = await response.json(); throw new Error(errorData.error || `Server Error: ${response.status}`); } return await response.json(); } catch (error) { console.error("Failed to fetch cline data:", error); return { error: error.message }; } }
    function resetToInitialState() { if (!scanner.classed("hidden")) return; switchToRadarView().then(() => { clearChart(); mainTitle.text("Enter a word to build its Radar").style("cursor", "default"); inputContainer.classed("hidden", false); senseSelector.classed("hidden", true); legend.classed("hidden", true); restartBtn.classed("hidden", true); exportBtn.classed("hidden", true); d3.select("#word-input").property("value", "").node().focus(); d3.select("#category-input").property("value", ""); d3.select("#custom-words-input").property("value", ""); d3.selectAll('.pos-option').classed('selected', false); d3.select("#submit-btn").classed("hidden", true); }); }
    function drawRadarBackground(axesData) { radarBgGroup.selectAll("*").remove(); const ringCount = 4; const ringWidth = maxRadius / ringCount; const ringColors = ["#2a2a4a", "#242442", "#1f1f3a", "#1a1a2e"]; radarBgGroup.selectAll(".radar-ring").data(d3.range(ringCount - 1, -1, -1)).enter().append("circle").attr("class", "radar-ring").attr("r", d => (d + 1) * ringWidth).style("fill", (d, i) => ringColors[i]); radarBgGroup.append("line").attr("class", "quadrant-line").attr("id", "radar-line-v").attr("x1", 0).attr("y1", -maxRadius).attr("x2", 0).attr("y2", maxRadius); radarBgGroup.append("line").attr("class", "quadrant-line").attr("id", "radar-line-h").attr("x1", -maxRadius).attr("y1", 0).attr("x2", maxRadius).attr("y2", 0); if (axesData) { const labelOffset = maxRadius + 8; labelsGroup.append("text").attr("class", "ring-label").attr("x", -labelOffset).attr("y", 5).attr("text-anchor", "end").text(axesData.x.labels[0]); labelsGroup.append("text").attr("class", "ring-label").attr("x", labelOffset).attr("y", 5).attr("text-anchor", "start").text(axesData.x.labels[1]); labelsGroup.append("text").attr("class", "ring-label").attr("x", 0).attr("y", -labelOffset + 5).attr("text-anchor", "middle").text(axesData.y.labels[1]); labelsGroup.append("text").attr("class", "ring-label").attr("x", 0).attr("y", labelOffset + 5).attr("text-anchor", "middle").text(axesData.y.labels[0]); } }
    function drawSpectrumView() { spectrumGroup.selectAll("*").remove(); spectrumGroup.append("line").attr("class", "spectrum-axis").attr("x1", -maxRadius * 0.9).attr("x2", maxRadius * 0.9); spectrumGroup.append("line").attr("class", "spectrum-axis").attr("x1", 0).attr("y1", -50).attr("x2", 0).attr("y2", 50); const labelPadding = isMobile ? 12 : 25; spectrumGroup.append("text").attr("class", "spectrum-label spectrum-label-left").attr("x", -maxRadius * 0.9 - labelPadding).attr("text-anchor", "end").attr("dominant-baseline", "middle"); spectrumGroup.append("text").attr("class", "spectrum-label spectrum-label-right").attr("x", maxRadius * 0.9 + labelPadding).attr("text-anchor", "start").attr("dominant-baseline", "middle"); }
    function setupTooltipEvents(selection) { selection.on("click", handleWordClick).on("mouseover", (event, d) => { if (selectedWords.length > 0) return; if (!d.isAntonym) speak(d.term); tooltip.transition().duration(200).style("opacity", .95); const metadataHTML = getMetadataHTML(d); tooltip.html(`<h3>${d.term}</h3><p>${d.definition}</p><div class="example">e.g., "${d.example}"</div>${metadataHTML}`); const r = tooltip.node().getBoundingClientRect(); let l = event.pageX + 15, t = event.pageY - 28; if (l + r.width > window.innerWidth) l = event.pageX - r.width - 15; if (t + r.height > window.innerHeight) t = event.pageY - r.height - 15; if (t < 0) t = event.pageY + 15; tooltip.style("left", l + "px").style("top", t + "px"); }).on("mouseout", () => { if (selectedWords.length === 0) { tooltip.transition().duration(500).style("opacity", 0); } }); }
    function clearComparison() { if (!currentBubbles && !currentClineBubbles) return; selectedWords = []; if(currentBubbles) currentBubbles.classed("selected", false).classed("dimmed", false); if(currentClineBubbles) currentClineBubbles.classed("selected", false).classed("dimmed", false); tooltip.style("opacity", 0).classed("comparison-tooltip", false); }
    function showComparisonTooltip(d1, d2) { const content = `<div class="comparison-close" onclick="d3.select('.tooltip').style('opacity', 0); d3.selectAll('.word-bubble').classed('selected dimmed', false); window.selectedWords = [];">×</div><h3>Comparing Words</h3><div class="comparison-grid"><div class="comparison-col"><h4>${d1.term}</h4><p>${d1.definition}</p><div class="example">e.g., "${d1.example}"</div>${getMetadataHTML(d1)}</div><div class="comparison-col"><h4>${d2.term}</h4><p>${d2.definition}</p><div class="example">e.g., "${d2.example}"</div>${getMetadataHTML(d2)}</div></div><div class="metadata"><strong>Tip:</strong> Click the background to clear.</div>`; tooltip.html(content).classed("comparison-tooltip", true).style("opacity", 0).style("left", null).style("top", null); requestAnimationFrame(() => { tooltip.transition().duration(200).style("opacity", 0.95); if (!isMobile) { tooltip.style("left", `${width / 2 - tooltip.node().getBoundingClientRect().width / 2}px`).style("top", `${height / 2 - tooltip.node().getBoundingClientRect().height / 2}px`); } }); }
    function speak(text, lang = 'en-US') { if ('speechSynthesis' in window && isSoundOn) { window.speechSynthesis.cancel(); const u = new SpeechSynthesisUtterance(text); u.lang = lang; window.speechSynthesis.speak(u); } }
    function getMetadataHTML(d) { const difficultyHTML = d.difficulty ? `<span class="difficulty ${d.difficulty.toLowerCase()}">${d.difficulty}</span>` : ''; let freqLevel = 0; if (d.frequency > 0) { freqLevel = Math.ceil((d.frequency / 100) * 4); } const frequencyHTML = `<div class="frequency-indicator freq-${freqLevel}" title="Frequency: ${d.frequency}/100"><div class="freq-bar"></div><div class="freq-bar"></div><div class="freq-bar"></div><div class="freq-bar"></div></div>`; return `<div class="metadata"><div class="metadata-item">${difficultyHTML}${frequencyHTML}</div></div>`; }
    function setupSoundToggle() { d3.select("#sound-toggle").on("click", () => { isSoundOn = !isSoundOn; d3.select("#sound-toggle").classed("sound-off", !isSoundOn).select(".control-label").text(isSoundOn ? "Sound ON" : "Sound OFF"); if (!isSoundOn) { window.speechSynthesis.cancel(); } }); }
    function exportAsPNG() { const exportArea = d3.select("#chart-container").node(); html2canvas(exportArea, { backgroundColor: '#1a1a2e', scale: 2, logging: false, useCORS: true }).then(canvas => { const ctx = canvas.getContext('2d'); const text = "Word Radar by ELTcation - www.eltcation.com"; const padding = 25; ctx.font = 'bold 24px sans-serif'; ctx.fillStyle = 'rgba(224, 224, 224, 0.6)'; ctx.textAlign = 'center'; ctx.fillText(text, canvas.width / 2, canvas.height - padding); const pngUrl = canvas.toDataURL("image/png"); const link = document.createElement("a"); const fileName = `word-radar-${currentRadarData?.hub_word || 'export'}.png`; link.download = fileName; link.href = pngUrl; document.body.appendChild(link); link.click(); document.body.removeChild(link); }).catch(err => { console.error("html2canvas failed:", err); alert("Sorry, there was an error exporting the image."); }); }
    async function fetchWordData(word, partOfSpeech, category, synonyms = null) { try { const requestBody = { word, partOfSpeech, category }; if (synonyms) { requestBody.synonyms = synonyms; } const response = await fetch('/.netlify/functions/word-radar-data', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestBody) }); if (!response.ok) { const errorData = await response.json(); throw new Error(errorData.error || `Server Error: ${response.status}`); } return await response.json(); } catch (error) { console.error("Failed to fetch word data:", error); return { error: error.message }; } }
});
</script>