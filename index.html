<!DOCTYPE html>
<html lang="en">
<head>
    <!-- ... (head content is unchanged) ... -->
    <style>
        /* ... (styles are unchanged) ... */
    </style>
</head>
<body>
    <!-- ... (body HTML is unchanged) ... -->

<script>
    document.addEventListener('DOMContentLoaded', function() {
        const mainTitle = d3.select("#main-title");
        const inputContainer = d3.select("#input-container");
        const wordForm = d3.select("#word-form");
        const scanner = d3.select("#radar-scanner");
        const tooltip = d3.select(".tooltip");
        const legend = d3.select("#legend");
        const senseSelector = d3.select("#sense-selector");
        const restartBtn = d3.select("#restart-btn");
        const exportBtn = d3.select("#export-btn");
        
        const container = d3.select("#chart-container");
        const containerRect = container.node().getBoundingClientRect();
        const width = containerRect.width;
        const height = containerRect.height;
        
        const isMobile = window.innerWidth <= 768;
        const margin = isMobile ? 65 : 100;
        const maxRadius = (Math.min(width, height) / 2) - margin;
        
        const svg = container.append("svg").attr("width", width).attr("height", height).attr("viewBox", `0 0 ${width} ${height}`).attr("preserveAspectRatio", "xMidYMid meet")
            .on("click", (event) => {
                if (selectedWords.length > 0) { clearComparison(); } 
                else if (currentView !== 'radar') { event.stopPropagation(); switchToRadarView(); }
            });

        const chartGroup = svg.append("g").attr("transform", `translate(${width / 2}, ${height / 2})`);

        // MODIFIED: Added spectrumBubbles to track temporary bubbles
        let currentView = 'radar', activeSpectrum = null, currentBubbles = null, currentAntonymBubbles = null, spectrumBubbles = null, selectedWords = [], isSoundOn = true, currentRadarData = null;

        const bubbleSizeScale = d3.scaleSqrt().domain([0, 100]).range(isMobile ? [5, 20] : [8, 30]);
        const largestBubbleRadius = bubbleSizeScale.range()[1]; 

        const difficultyColors = {
            beginner: '#4CAF50',
            intermediate: '#FF9800',
            advanced: '#F44336'
        };
        
        const radarXScale = d3.scaleLinear().domain([-1.1, 1.1]).range([-maxRadius + largestBubbleRadius, maxRadius - largestBubbleRadius]);
        const radarYScale = d3.scaleLinear().domain([-1.1, 1.1]).range([maxRadius - largestBubbleRadius, -maxRadius + largestBubbleRadius]);

        const spectrumRange = maxRadius * 0.8;
        const spectrumScale = d3.scaleLinear().domain([-1, 1]).range([-spectrumRange, spectrumRange]).clamp(true);

        const radarBgGroup = chartGroup.append("g").attr("class", "radar-background");
        const spectrumGroup = chartGroup.append("g").attr("class", "spectrum-view").style("opacity", 0).attr("pointer-events", "none");
        const bubblesGroup = chartGroup.append("g").attr("class", "bubbles-container");
        const antonymsGroup = chartGroup.append("g").attr("class", "antonyms-container");
        const labelsGroup = chartGroup.append("g").attr("class", "labels-container");
        
        const submitBtn = d3.select("#submit-btn");
        let currentSearch = { word: '', partOfSpeech: '' };
        
        function updateSubmitButtonState() {
            const word = d3.select("#word-input").property("value").trim();
            const posSelected = d3.select(".pos-option.selected").node();
            if (word && posSelected) {
                submitBtn.classed("hidden", false);
            } else {
                submitBtn.classed("hidden", true);
            }
        }

        async function handleFormSubmit(event) {
            event.preventDefault();
            
            currentSearch.word = d3.select("#word-input").property("value").trim();
            const selectedPosNode = d3.select(".pos-option.selected").node();
            const customWords = d3.select("#custom-words-input").property("value").trim();

            if (!currentSearch.word) { alert("Please enter a word."); return; }
            if (!selectedPosNode) { alert("Please select a part of speech."); return; }
            
            currentSearch.partOfSpeech = selectedPosNode.dataset.pos;
            
            if (currentView !== 'radar') { await switchToRadarView(); }

            inputContainer.classed("hidden", true);
            legend.classed("hidden", true);
            clearChart();

            if (customWords) {
                const synonyms = customWords.split(',').map(s => s.trim()).filter(Boolean);
                if (synonyms.length > 0) {
                    handleSenseSelection(synonyms);
                    return;
                }
            }
            
            mainTitle.style("cursor", "default").text(`Discovering meanings for "${currentSearch.word}"...`);
            scanner.classed("hidden", false);
            const discoveryData = await fetchWordData(currentSearch.word, currentSearch.partOfSpeech);
            
            if (discoveryData && discoveryData.senses) {
                scanner.classed("hidden", true);
                mainTitle.text("Please select a meaning to explore");
                senseSelector.select("#sense-title").text(`Which meaning of "${currentSearch.word}"?`);
                
                senseSelector.select("#sense-options").selectAll("*").remove();
                
                const primaryOptions = senseSelector.select("#sense-options")
                    .selectAll(".primary-sense")
                    .data(discoveryData.senses);
                    
                primaryOptions.enter()
                    .append("button")
                    .attr("class", "sense-option-btn primary-sense")
                    .text(d => `"${d.synonyms.slice(0, 3).join('", "')}" ${d.synonyms.length > 3 ? `(+${d.synonyms.length - 3} more)` : ''} — ${d.definition}`)
                    .on("click", (e, d) => handleSenseSelection(d.synonyms));
                
                if (discoveryData.hasMore && discoveryData.additionalSenses) {
                    const showMoreContainer = senseSelector.select("#sense-options")
                        .append("div")
                        .attr("id", "show-more-container");
                        
                    showMoreContainer.append("div")
                        .attr("id", "show-more-btn")
                        .text(`+ Show ${discoveryData.additionalSenses.length} more specific meanings`)
                        .on("click", function() {
                            const additionalContainer = d3.select("#additional-senses");
                            const isExpanded = additionalContainer.classed("expanded");
                            
                            if (!isExpanded) {
                                additionalContainer.classed("expanded", true);
                                d3.select(this).text("− Show fewer meanings");
                            } else {
                                additionalContainer.classed("expanded", false);
                                d3.select(this).text(`+ Show ${discoveryData.additionalSenses.length} more specific meanings`);
                            }
                        });
                    
                    showMoreContainer.append("div").attr("class", "sense-divider");
                    
                    const additionalContainer = showMoreContainer.append("div")
                        .attr("id", "additional-senses")
                        .attr("class", "additional-senses");
                        
                    const additionalOptions = additionalContainer.selectAll(".additional-sense")
                        .data(discoveryData.additionalSenses);
                        
                    additionalOptions.enter()
                        .append("button")
                        .attr("class", "sense-option-btn additional-sense")
                        .style("opacity", "0.8")
                        .style("font-size", "clamp(13px, 3vw, 15px)")
                        .text(d => `"${d.synonyms.slice(0, 2).join('", "')}" ${d.synonyms.length > 2 ? `(+${d.synonyms.length - 2})` : ''} — ${d.definition}`)
                        .on("click", (e, d) => handleSenseSelection(d.synonyms));
                }
                
                senseSelector.classed("hidden", false);

            } else if (discoveryData && discoveryData.words) {
                currentRadarData = discoveryData;
                scanner.classed("hidden", true);
                mainTitle.text(`Word Radar: "${discoveryData.hub_word}"`).style("cursor", "pointer");
                updateLegend(discoveryData);
                drawRadarBackground();
                drawWordBubbles(discoveryData);
                legend.classed("hidden", false);
                restartBtn.classed("hidden", false);
                exportBtn.classed("hidden", false);
            } else {
                scanner.classed("hidden", true);
                mainTitle.text(discoveryData.error || `No data for "${currentSearch.word}". Click to try again.`).style("cursor", "pointer");
                restartBtn.classed("hidden", false);
            }
        }

        async function handleSenseSelection(synonyms) {
            senseSelector.classed("hidden", true);
            mainTitle.style("cursor", "default").text(`Generating Radar for "${currentSearch.word}"...`);
            scanner.classed("hidden", false);

            const wordData = await fetchWordData(currentSearch.word, currentSearch.partOfSpeech, synonyms);
            currentRadarData = wordData;
            scanner.classed("hidden", true);

            if (wordData && wordData.words) {
                mainTitle.text(`Word Radar: "${wordData.hub_word}"`).style("cursor", "pointer");
                updateLegend(wordData);
                drawRadarBackground();
                drawWordBubbles(wordData);
                legend.classed("hidden", false);
                restartBtn.classed("hidden", false);
                exportBtn.classed("hidden", false);
            } else {
                mainTitle.text(wordData.error || `No data for "${currentSearch.word}". Click to try again.`).style("cursor", "pointer");
                restartBtn.classed("hidden", false);
            }
        }

        function getMetadataHTML(d) {
            const difficultyHTML = d.difficulty ? `<span class="difficulty ${d.difficulty.toLowerCase()}">${d.difficulty}</span>` : '';
            let freqLevel = 0;
            if (d.frequency > 0) {
                freqLevel = Math.ceil((d.frequency / 100) * 4);
            }
            const frequencyHTML = `
                <div class="frequency-indicator freq-${freqLevel}" title="Frequency: ${d.frequency}/100">
                    <div class="freq-bar"></div>
                    <div class="freq-bar"></div>
                    <div class="freq-bar"></div>
                    <div class="freq-bar"></div>
                </div>
            `;
            return `<div class="metadata"><div class="metadata-item">${difficultyHTML}${frequencyHTML}</div></div>`;
        }

        function handleWordClick(event, d) {
            event.stopPropagation(); tooltip.style("opacity", 0);
            const node = d3.select(event.currentTarget);
            const isSelected = selectedWords.some(sw => sw.term === d.term);
            if (isSelected) {
                selectedWords = selectedWords.filter(sw => sw.term !== d.term);
                node.classed("selected", false);
            } else { if (selectedWords.length < 2) { selectedWords.push(d); node.classed("selected", true); } }
            if (selectedWords.length === 2) {
                showComparisonTooltip(selectedWords[0], selectedWords[1]);
                const allBubbles = d3.selectAll('.word-bubble'); // Select all bubbles on screen
                allBubbles.classed("dimmed", data => !selectedWords.some(sw => sw.term === data.term));
            } else { 
                tooltip.classed("comparison-tooltip", false); 
                d3.selectAll('.word-bubble').classed("dimmed", false); 
            }
        }

        function clearComparison() {
            if (!currentBubbles && !spectrumBubbles) return; 
            selectedWords = [];
            d3.selectAll('.word-bubble').classed("selected", false).classed("dimmed", false);
            tooltip.style("opacity", 0).classed("comparison-tooltip", false);
        }
        
        function showComparisonTooltip(d1, d2) {
            const content = `
                <div class="comparison-close" onclick="d3.select('.tooltip').style('opacity', 0); d3.selectAll('.word-bubble').classed('selected dimmed', false); window.selectedWords = [];">×</div>
                <h3>Comparing Words</h3>
                <div class="comparison-grid">
                    <div class="comparison-col">
                        <h4>${d1.term}</h4>
                        <p>${d1.definition}</p>
                        <div class="example">e.g., "${d1.example}"</div>
                        ${getMetadataHTML(d1)} 
                    </div>
                    <div class="comparison-col">
                        <h4>${d2.term}</h4>
                        <p>${d2.definition}</p>
                        <div class="example">e.g., "${d2.example}"</div>
                        ${getMetadataHTML(d2)}
                    </div>
                </div>
                <div class="metadata"><strong>Tip:</strong> Click the background to clear.</div>`;
            tooltip.html(content).classed("comparison-tooltip", true).style("opacity", 0).style("left", null).style("top", null);
            requestAnimationFrame(() => {
                tooltip.transition().duration(200).style("opacity", 0.95);
                if (!isMobile) {
                    tooltip.style("left", `${width / 2 - tooltip.node().getBoundingClientRect().width / 2}px`).style("top", `${height / 2 - tooltip.node().getBoundingClientRect().height / 2}px`);
                }
            });
        }

        function speak(text, lang = 'en-US') { if ('speechSynthesis' in window && isSoundOn) { window.speechSynthesis.cancel(); const u = new SpeechSynthesisUtterance(text); u.lang = lang; window.speechSynthesis.speak(u); } }

        function setupTooltipEvents(selection) {
            selection.on("click", handleWordClick).on("mouseover", (event, d) => {
                if (selectedWords.length > 0) return; speak(d.term);
                tooltip.transition().duration(200).style("opacity", .95);
                const metadataHTML = getMetadataHTML(d);
                tooltip.html(`<h3>${d.term}</h3><p>${d.definition}</p><div class="example">e.g., "${d.example}"</div>${metadataHTML}`);
        
                const r = tooltip.node().getBoundingClientRect(); let l = event.pageX + 15, t = event.pageY - 28;
                if (l + r.width > window.innerWidth) l = event.pageX - r.width - 15;
                if (t + r.height > window.innerHeight) t = event.pageY - r.height - 15;
                if (t < 0) t = event.pageY + 15;
                tooltip.style("left", l + "px").style("top", t + "px");
            }).on("mouseout", () => { if (selectedWords.length === 0) { tooltip.transition().duration(500).style("opacity", 0); } });
        }
        
        function exportAsPNG() {
            const exportArea = d3.select("#chart-container").node();
            html2canvas(exportArea, {
                backgroundColor: '#1a1a2e',
                scale: 2, 
                logging: false,
                useCORS: true
            }).then(canvas => {
                const ctx = canvas.getContext('2d');
                const text = "Word Radar by ELTcation - www.eltcation.com";
                const padding = 25; 
                ctx.font = 'bold 24px sans-serif'; 
                ctx.fillStyle = 'rgba(224, 224, 224, 0.6)';
                ctx.textAlign = 'center';
                ctx.fillText(text, canvas.width / 2, canvas.height - padding);

                const pngUrl = canvas.toDataURL("image/png");
                const link = document.createElement("a");
                const fileName = `word-radar-${currentRadarData?.hub_word || 'export'}.png`;
                link.download = fileName;
                link.href = pngUrl;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }).catch(err => {
                console.error("html2canvas failed:", err);
                alert("Sorry, there was an error exporting the image.");
            });
        }
        
        // MODIFIED: This function can now fetch both radar and spectrum data
        async function fetchWordData(word, partOfSpeech, synonyms = null, antonym = null) {
            try {
                const requestBody = { word, partOfSpeech };
                if (synonyms) { requestBody.synonyms = synonyms; }
                if (antonym) { requestBody.antonym = antonym; } // <-- Add antonym if present

                const response = await fetch('/.netlify/functions/word-radar-data', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || `Server Error: ${response.status}`);
                }
                return await response.json();
            } catch (error) {
                console.error("Failed to fetch word data:", error);
                return { error: error.message };
            }
        }
        
        submitBtn.on("click", (event) => { event.preventDefault(); handleFormSubmit(event); });
        drawRadarBackground();
        drawSpectrumView();
        wordForm.on("submit", handleFormSubmit);
        d3.selectAll('#category-input, #custom-words-input').on('keydown', function(event) { if (event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); handleFormSubmit(event); }});
        d3.select('#word-input').on('input', updateSubmitButtonState);
        d3.selectAll('.pos-option').on('click', function() { d3.selectAll('.pos-option').classed('selected', false); d3.select(this).classed('selected', true); updateSubmitButtonState(); });
        mainTitle.on("click", resetToInitialState);
        setupSoundToggle();
        restartBtn.on("click", resetToInitialState);
        exportBtn.on("click", exportAsPNG);
        function setupSoundToggle() {
            d3.select("#sound-toggle").on("click", () => {
                isSoundOn = !isSoundOn;
                d3.select("#sound-toggle").classed("sound-off", !isSoundOn)
                    .select(".control-label").text(isSoundOn ? "Sound ON" : "Sound OFF");
                if (!isSoundOn) { window.speechSynthesis.cancel(); }
            });
        }
        
        function resetToInitialState() {
            if (!scanner.classed("hidden")) return;
            switchToRadarView().then(() => {
                clearChart();
                mainTitle.text("Enter a word to build its Radar").style("cursor", "default");
                inputContainer.classed("hidden", false);
                senseSelector.classed("hidden", true);
                legend.classed("hidden", true);
                restartBtn.classed("hidden", true);
                exportBtn.classed("hidden", true);
                d3.select("#word-input").property("value", "").node().focus();
                d3.select("#custom-words-input").property("value", "");
                d3.selectAll('.pos-option').classed('selected', false);
                d3.select("#submit-btn").classed("hidden", true);
            });
        }
        
        function drawRadarBackground() {
            radarBgGroup.selectAll("*").remove(); 
            const ringCount = 4;
            const ringWidth = maxRadius / ringCount;
            radarBgGroup.selectAll(".radar-ring").data(d3.range(ringCount - 1, -1, -1)).enter().append("circle").attr("class", "radar-ring").attr("r", d => (d + 1) * ringWidth).style("fill", "none");
            
            radarBgGroup.append("line").attr("class", "axis-line").attr("id", "radar-line-v").attr("x1", 0).attr("y1", -maxRadius).attr("x2", 0).attr("y2", maxRadius);
            radarBgGroup.append("line").attr("class", "axis-line").attr("id", "radar-line-h").attr("x1", -maxRadius).attr("y1", 0).attr("x2", maxRadius).attr("y2", 0);
        }
        
        function drawSpectrumView() {
            spectrumGroup.selectAll("*").remove();
            spectrumGroup.append("line").attr("class", "spectrum-axis").attr("x1", -maxRadius * 0.9).attr("x2", maxRadius * 0.9);
            spectrumGroup.append("line").attr("class", "spectrum-axis").attr("x1", 0).attr("y1", -50).attr("x2", 0).attr("y2", 50);
            const labelPadding = isMobile ? 12 : 25;
            spectrumGroup.append("text").attr("class", "spectrum-label spectrum-label-left").attr("x", -maxRadius * 0.9 - labelPadding).attr("text-anchor", "end").attr("dominant-baseline", "middle");
            spectrumGroup.append("text").attr("class", "spectrum-label spectrum-label-right").attr("x", maxRadius * 0.9 + labelPadding).attr("text-anchor", "start").attr("dominant-baseline", "middle");
        }

        function drawWordBubbles(radarData) {
            const labelOffset = maxRadius + (isMobile ? 15 : 25);
            const axisLabels = [
                { text: 'FORMAL', x: 0, y: -labelOffset, anchor: 'middle', spectrumType: 'formality', spectrumName: 'Formality', labels: ['INFORMAL', 'FORMAL'] },
                { text: 'FIGURATIVE', x: labelOffset, y: 0, anchor: 'start', spectrumType: 'style', spectrumName: 'Style', labels: ['LITERAL', 'FIGURATIVE'] },
                { text: 'INFORMAL', x: 0, y: labelOffset, anchor: 'middle', spectrumType: 'formality', spectrumName: 'Formality', labels: ['INFORMAL', 'FORMAL'] },
                { text: 'LITERAL', x: -labelOffset, y: 0, anchor: 'end', spectrumType: 'style', spectrumName: 'Style', labels: ['LITERAL', 'FIGURATIVE'] }
            ];

            labelsGroup.selectAll(".axis-label").data(axisLabels).enter().append("text")
                .attr("class", "axis-label")
                .attr("x", d => d.x).attr("y", d => d.y)
                .attr("text-anchor", d => d.anchor)
                .attr("dominant-baseline", "middle")
                .text(d => d.text)
                .on("click", (e, d) => {
                    e.stopPropagation();
                    switchToSpectrumView(d.spectrumType, {
                        name: d.spectrumName,
                        labels: d.labels
                    });
                });

            const nodes = radarData.words.map(d => {
                d.radarX = radarXScale(d.style);
                d.radarY = radarYScale(d.formality);
                return d;
            });

            const simulation = d3.forceSimulation(nodes)
                .force("collide", d3.forceCollide(d => bubbleSizeScale(d.frequency) + 4).strength(1))
                .force("x", d3.forceX(d => d.radarX).strength(0.1))
                .force("y", d3.forceY(d => d.radarY).strength(0.1))
                .stop();
            
            for (let i = 0; i < 300; ++i) simulation.tick();
            
            currentBubbles = bubblesGroup.selectAll(".word-bubble")
                .data(nodes, d => d.term)
                .enter().append("g").attr("class", "word-bubble");

            currentBubbles.append("circle").attr("r", 0).style("fill", d => difficultyColors[d.difficulty] || '#1f77b4')
                .transition().duration(500).delay((d,i) => i * 20).attr("r", d => bubbleSizeScale(d.frequency));
            currentBubbles.append("text").text(d => d.term).attr("dy", "0.3em").style("opacity", 0)
                .transition().duration(500).delay((d,i) => i * 20).style("opacity", 1);
            currentBubbles.attr("transform", d => `translate(${d.x}, ${d.y})`);
            setupTooltipEvents(currentBubbles);

            const antonymRadius = maxRadius + (isMobile ? 35 : 50);
            const quadrantCenters = [ -Math.PI / 4, Math.PI / 4, 3 * Math.PI / 4, 5 * Math.PI / 4 ];
            const spreadAngle = Math.PI / 8; 
            const antonymNodes = radarData.antonyms.map((ant, i) => {
                const baseAngle = quadrantCenters[i % 4];
                const offset = (Math.floor(i / 4) % 2 === 0 ? 1 : -1) * Math.floor(i / 4) * spreadAngle;
                const angle = baseAngle + offset;
                return { term: ant, x: antonymRadius * Math.cos(angle), y: antonymRadius * Math.sin(angle) };
            });
            
            currentAntonymBubbles = antonymsGroup.selectAll(".antonym-bubble")
                .data(antonymNodes, d => d.term)
                .enter().append("g").attr("class", "word-bubble antonym-bubble");

            currentAntonymBubbles.append("circle").attr("r", 0).style("fill", "#d62728")
                .transition().duration(500).delay((d, i) => 500 + i * 50).attr("r", isMobile ? 12 : 16);
            currentAntonymBubbles.append("text").text(d => d.term).attr("dy", "0.3em").style("opacity", 0)
                .transition().duration(500).delay((d, i) => 500 + i * 50).style("opacity", 1);
            currentAntonymBubbles.attr("transform", d => `translate(${d.x}, ${d.y})`);
            
            // MODIFIED: Click handler now fetches data before switching view
            currentAntonymBubbles.on("click", async (e, d) => {
                e.stopPropagation();
                mainTitle.text(`Generating spectrum for "${currentRadarData.hub_word}" vs "${d.term}"...`);
                scanner.classed("hidden", false);
                try {
                    const spectrumData = await fetchWordData(currentRadarData.hub_word, null, null, d.term);
                    scanner.classed("hidden", true);
                    if (spectrumData && spectrumData.words) {
                        switchToSpectrumView('antonym', spectrumData);
                    } else {
                        mainTitle.text(spectrumData.error || "Could not generate spectrum.");
                    }
                } catch (error) {
                    scanner.classed("hidden", true);
                    mainTitle.text("Error generating spectrum.");
                    console.error(error);
                }
            }).on("mouseover", (e, d) => {
                speak(d.term);
                tooltip.transition().duration(200).style("opacity", .95);
                tooltip.html(`<h3>${d.term}</h3><p><em>An opposite of "${currentRadarData.hub_word}"</em></p>`);
            }).on("mouseout", () => tooltip.transition().duration(500).style("opacity", 0));
        }
        
        function clearChart() {
            clearComparison();
            if (currentBubbles) currentBubbles.remove();
            if (currentAntonymBubbles) currentAntonymBubbles.remove();
            // NEW: Also clear temporary spectrum bubbles
            if (spectrumBubbles) {
                spectrumBubbles.remove();
                spectrumBubbles = null;
            }
            labelsGroup.selectAll(".axis-label").remove();
            updateLegend(null);
        }

        // =================================================================
        // START: REVISED FUNCTION
        // This function is completely rewritten to handle both cases.
        // =================================================================
        function switchToSpectrumView(type, data) {
            clearComparison();
            currentView = 'spectrum';
            activeSpectrum = type;

            // Animate out radar elements
            labelsGroup.transition().duration(500).style("opacity", 0).attr("pointer-events", "none");
            antonymsGroup.transition().duration(500).style("opacity", 0).attr("pointer-events", "none");
            radarBgGroup.transition().duration(500).style("opacity", 0);
            
            // Animate in spectrum elements
            spectrumGroup.transition().delay(200).duration(500).style("opacity", 1).attr("pointer-events", "auto");

            if (type === 'antonym') {
                // Case 1: Displaying the new antonym spectrum (your cline builder)
                mainTitle.text(`Spectrum: "${data.start_word}" vs "${data.end_word}"`);
                spectrumGroup.select(".spectrum-label-left").text(data.start_word.toUpperCase());
                spectrumGroup.select(".spectrum-label-right").text(data.end_word.toUpperCase());

                // Hide original radar bubbles
                if (currentBubbles) {
                    currentBubbles.transition().duration(500).style("opacity", 0).attr("pointer-events", "none");
                }
                
                // Filter out the start and end words to avoid redundant bubbles if the API includes them
                // This step may not be strictly necessary if your API is perfect, but it's good practice.
                const spectrumNodes = data.words;

                const spectrumSimulation = d3.forceSimulation(spectrumNodes)
                    .force("x", d3.forceX(node => spectrumScale(node.spectrum_position)).strength(1))
                    .force("y", d3.forceY(0).strength(0.05))
                    .force("collide", d3.forceCollide(node => bubbleSizeScale(node.frequency) + (isMobile ? 2 : 3)).strength(0.8))
                    .stop();
                for (let i = 0; i < 150; ++i) { spectrumSimulation.tick(); }

                // Create the temporary spectrum bubbles
                spectrumBubbles = bubblesGroup.selectAll(".spectrum-bubble-temp")
                    .data(spectrumNodes, d => d.term)
                    .enter().append("g")
                    .attr("class", "word-bubble spectrum-bubble-temp");

                // =================================================================
                // START OF THE FIX
                // This crucial line applies the X and Y coordinates calculated by the simulation.
                // Without it, all bubbles would be drawn at [0,0].
                spectrumBubbles.attr("transform", d => `translate(${d.x}, ${d.y})`);
                // END OF THE FIX
                // =================================================================

                spectrumBubbles.append("circle")
                    .attr("r", 0).style("fill", d => difficultyColors[d.difficulty] || '#1f77b4')
                    .transition().duration(500).delay((d, i) => 200 + i * 20)
                    .attr("r", d => bubbleSizeScale(d.frequency));
                
                spectrumBubbles.append("text")
                    .text(d => d.term).attr("dy", "0.3em").style("opacity", 0)
                    .transition().duration(500).delay((d, i) => 200 + i * 20)
                    .style("opacity", 1);
                
                setupTooltipEvents(spectrumBubbles);

            } else {
                // Case 2: Displaying formality/style spectrum (rearranges existing bubbles)
                mainTitle.text(`Spectrum: ${data.name}`);
                spectrumGroup.select(".spectrum-label-left").text(data.labels[0].toUpperCase());
                spectrumGroup.select(".spectrum-label-right").text(data.labels[1].toUpperCase());

                const allNodes = currentBubbles.data();
                const spectrumSimulation = d3.forceSimulation(allNodes)
                    .force("x", d3.forceX(d => spectrumScale(d[type])).strength(1))
                    .force("y", d3.forceY(0).strength(0.05))
                    .force("collide", d3.forceCollide(d => bubbleSizeScale(d.frequency) + (isMobile ? 2 : 3)).strength(0.8))
                    .stop();
                for (let i = 0; i < 150; ++i) { spectrumSimulation.tick(); }
                
                currentBubbles.transition().duration(750).ease(d3.easeCubicOut)
                    .style("opacity", 1).attr("pointer-events", "auto")
                    .attr("transform", d => `translate(${d.x}, ${d.y})`);
            }
        }
        // =================================================================
        // END: REVISED FUNCTION
        // =================================================================


        // MODIFIED: This function now knows how to clean up the temporary bubbles
        function switchToRadarView() {
            return new Promise(resolve => {
                if (currentView !== 'spectrum') { resolve(); return; }
                clearComparison(); 
                currentView = 'radar';
                
                // NEW: Clean up the temporary spectrum bubbles when returning
                if (spectrumBubbles) {
                    spectrumBubbles.remove();
                    spectrumBubbles = null;
                }
                
                activeSpectrum = null;
                if(currentRadarData) mainTitle.text(`Word Radar: "${currentRadarData.hub_word}"`);
                
                spectrumGroup.transition().duration(500).style("opacity", 0).attr("pointer-events", "none");
                radarBgGroup.transition().delay(200).duration(500).style("opacity", 1);
                labelsGroup.transition().delay(200).duration(500).style("opacity", 1).attr("pointer-events", "auto");
                antonymsGroup.transition().delay(200).duration(500).style("opacity", 1).attr("pointer-events", "auto");

                if (currentBubbles) {
                    const nodes = currentBubbles.data();
                    const simulation = d3.forceSimulation(nodes)
                        .force("collide", d3.forceCollide(d => bubbleSizeScale(d.frequency) + 3).strength(0.8))
                        .force("x", d3.forceX(d => d.radarX).strength(0.1))
                        .force("y", d3.forceY(d => d.radarY).strength(0.1))
                        .stop();
                    for (let i = 0; i < 200; ++i) simulation.tick();

                    currentBubbles.transition().duration(750).ease(d3.easeCubicOut)
                        .style("opacity", 1).attr("pointer-events", "auto")
                        .attr("transform", d => `translate(${d.x}, ${d.y})`)
                        .end().then(resolve);
                } else { resolve(); }
            });
        }
        
        function updateLegend(data) {
            legend.classed("hidden", !data);
        }
    });
    </script>
</body>
</html>