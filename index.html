<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word Radar</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #1a1a2e;
            color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            min-height: 100vh;
            margin: 0;
            overflow: hidden;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        #input-container { 
            position: absolute; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }

        #word-input { 
            background: rgba(255, 255, 255, 0.1); 
            border: 2px solid #9a9ac8; 
            border-radius: 8px; 
            color: white; 
            font-size: clamp(16px, 5vw, 24px); 
            font-weight: bold; 
            text-align: center; 
            padding: clamp(8px, 2vw, 10px) clamp(15px, 4vw, 20px); 
            width: clamp(220px, 60vw, 300px); 
            outline: none; 
            transition: all 0.2s ease; 
            -webkit-text-size-adjust: 100%; 
        }
        #word-input:focus { background: rgba(255, 255, 255, 0.2); transform: scale(1.05); }

        #pos-selector {
            display: flex;
            gap: 10px;
        }
        .pos-option {
            background: rgba(40, 40, 60, 0.9);
            border: 1px solid #9a9ac8;
            border-radius: 8px;
            padding: 8px 16px;
            font-size: clamp(12px, 3vw, 14px);
            font-weight: 600;
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .pos-option:hover {
            background: rgba(255, 107, 71, 0.9);
        }
        .pos-option.selected {
            background-color: #FF6B47;
            color: #1a1a2e;
            border-color: #FF6B47;
            transform: scale(1.05);
        }

        #custom-words-input {
            background: rgba(255, 255, 255, 0.05);
            border: 1px dashed #7a7a9f;
            border-radius: 8px;
            color: white;
            font-size: clamp(12px, 3.5vw, 14px);
            text-align: center;
            padding: 8px 15px;
            width: clamp(220px, 60vw, 300px);
            outline: none;
            transition: all 0.2s ease;
            resize: vertical;
            height: 60px;
            text-align: left;
            padding: 10px;
        }
        #custom-words-input::placeholder {
            color: #9a9ac8;
            opacity: 0.7;
        }
        #custom-words-input:focus {
            background: rgba(255, 255, 255, 0.1);
            border-style: solid;
        }
        
        #submit-btn {
            background-color: #FF6B47;
            color: #1a1a2e;
            border: none;
            border-radius: 8px;
            padding: 12px 24px;
            font-size: clamp(14px, 4vw, 16px);
            font-weight: bold;
            cursor: pointer;
            margin-top: 10px;
            transition: all 0.2s ease;
            width: clamp(220px, 60vw, 300px);
        }
        #submit-btn:hover {
            transform: scale(1.05);
            background-color: #ffca85;
        }
        #sense-selector {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            background: rgba(40, 40, 60, 0.95);
            border: 1px solid #9a9ac8;
            border-radius: 12px;
            padding: clamp(20px, 5vw, 30px);
            max-height: 85vh;
            max-width: clamp(300px, 80vw, 500px);
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        #sense-title {
            margin: 0 0 10px 0;
            font-size: clamp(16px, 4vw, 20px);
            text-align: center;
        }
        #sense-options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 100%;
            overflow-y: auto;
            padding-right: 10px;
            margin-right: -10px;
        }

        #sense-options::-webkit-scrollbar { width: 8px; }
        #sense-options::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.2); border-radius: 4px; }
        #sense-options::-webkit-scrollbar-thumb { background-color: #7a7a9f; border-radius: 4px; }
        #sense-options::-webkit-scrollbar-thumb:hover { background-color: #9a9ac8; }
        .sense-option-btn {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #7a7a9f;
            border-radius: 8px;
            padding: 12px;
            color: #e0e0e0;
            font-size: clamp(14px, 3.5vw, 16px);
            cursor: pointer;
            text-align: left;
            transition: all 0.2s ease;
        }
        .sense-option-btn:hover {
            background: rgba(255, 107, 71, 0.9);
            border-color: #FF6B47;
            color: #1a1a2e;
        }
        .additional-senses { max-height: 0; overflow: hidden; transition: max-height 0.3s ease-out; }
        .additional-senses.expanded { max-height: 400px; }
        .sense-divider { height: 1px; background: linear-gradient(to right, transparent, #7a7a9f, transparent); margin: 15px 0 10px 0; }
        
        .header-logo { position: absolute; top: clamp(10px, 2vh, 20px); left: clamp(10px, 2vw, 20px); width: clamp(60px, 12vw, 90px); opacity: 1; transition: opacity 0.2s; }
        .header-logo:hover { opacity: 0.7; }
        
        #top-right-controls { position: absolute; top: clamp(10px, 2vh, 20px); right: clamp(10px, 2vw, 20px); display: flex; flex-direction: column; gap: 8px; align-items: flex-end; z-index: 100; }
        .control-btn { background: rgba(40, 40, 60, 0.9); border: 1px solid #9a9ac8; border-radius: 8px; padding: 6px 10px; display: flex; align-items: center; cursor: pointer; backdrop-filter: blur(5px); transition: all 0.2s; min-width: 130px; justify-content: center; }
        .control-btn:hover { background: rgba(60, 60, 80, 0.9); }
        .control-btn .control-icon { width: clamp(16px, 4vw, 20px); height: clamp(16px, 4vw, 20px); margin-right: 8px; fill: #c0c0e0; }
        .control-btn .control-label { font-size: clamp(10px, 2.5vw, 12px); font-weight: 600; color: #e0e0e0; }
        #sound-toggle.sound-off .slash-icon { display: block; }
        #sound-toggle.sound-off path:not(.slash-icon) { opacity: 0.4; }
        #sound-toggle .slash-icon { display: none; }
        
        h1 { color: #ffffff; font-weight: 300; text-align: center; cursor: pointer; transition: color 0.2s; font-size: clamp(1.2rem, 4vw, 2rem); margin: clamp(10px, 2vh, 20px) 10px; padding: 0 10px; }
        h1:hover { color: #ffca85; }
        #chart-container { position: relative; width: calc(100vw - 20px); height: calc(100vh - 80px); max-width: 800px; max-height: 800px; min-width: 300px; min-height: 300px; }
        .hidden { display: none !important; }
        #radar-scanner { position: absolute; top: 5%; left: 50%; margin-left: -1px; width: 2px; height: 45%; background: linear-gradient(to top, rgba(255, 107, 71, 0.8) 0%, rgba(255, 107, 71, 0) 100%); transform-origin: bottom center; animation: spin 3s linear infinite; z-index: 5; }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        .radar-background, .spectrum-view { transition: opacity 0.5s ease-in-out; }
        .radar-ring { stroke: #4f4f7a; stroke-width: 1px; fill: none; }
        .axis-line { stroke: #5f5f8a; stroke-width: 1.5px; }
        .axis-label { fill: #c0c0e0; font-size: clamp(12px, 3vw, 14px); font-weight: 600; text-transform: uppercase; cursor: pointer; transition: fill 0.2s ease-in-out; }
        .axis-label:hover { fill: #ffca85; }
        .spectrum-axis { stroke: #9a9ac8; stroke-width: 2px; stroke-dasharray: 4 4; }
        .spectrum-label { fill: #c0c0e0; font-size: clamp(12px, 3vw, 14px); font-weight: 600; text-transform: uppercase; text-anchor: middle; }
        .word-bubble { cursor: pointer; }
        .spectrum-bubble { cursor: grab; }
        .word-bubble circle, .spectrum-bubble circle { cursor: grab; transition: transform 0.2s, stroke-width 0.2s, stroke 0.2s; stroke: #1a1a2e; stroke-width: 2px; }
        .word-bubble:hover circle, .spectrum-bubble:hover circle { transform: scale(1.1); stroke: #ffffff; stroke-width: 3px; }
        .word-bubble.selected circle, .spectrum-bubble.selected circle { stroke: #ffca85; stroke-width: 4px; transform: scale(1.15); }
        .word-bubble.dimmed, .spectrum-bubble.dimmed { opacity: 0.25; pointer-events: none; }
        .word-bubble text, .spectrum-bubble text { fill: #ffffff; font-size: clamp(10px, 2.5vw, 12px); font-weight: bold; text-anchor: middle; pointer-events: none; text-shadow: 0 0 4px #000000; }
        .antonym-bubble circle { fill: #9467bd !important; }
        
        .tooltip { position: absolute; background-color: rgba(40, 40, 60, 0.95); border: 1px solid #9a9ac8; border-radius: 8px; padding: clamp(8px, 2vw, 12px); color: #e0e0e0; opacity: 0; pointer-events: none; transition: opacity 0.2s; max-width: clamp(220px, 70vw, 280px); font-size: clamp(12px, 3vw, 14px); box-shadow: 0 4px 15px rgba(0,0,0,0.4); backdrop-filter: blur(5px); z-index: 1000; }
        .tooltip h3 { margin: 0 0 4px 0; color: #ffffff; font-size: clamp(14px, 3.5vw, 16px); }
        .tooltip p { margin: 0 0 8px 0; font-style: italic; color: #c0c0e0; line-height: 1.3; }
        .tooltip .example { font-style: normal; background-color: rgba(0,0,0,0.2); padding: 4px; border-radius: 4px; font-family: monospace; font-size: clamp(11px, 2.5vw, 13px); }
        .tooltip .metadata { margin-top: 6px; padding-top: 6px; border-top: 1px solid #555; font-size: clamp(10px, 2.5vw, 12px); }
        .tooltip .difficulty { display: inline-block; padding: 2px 4px; border-radius: 3px; font-size: clamp(8px, 2vw, 10px); font-weight: bold; text-transform: uppercase; }
        .difficulty.beginner { background-color: #4CAF50; color: white; }
        .difficulty.intermediate { background-color: #FF9800; color: white; }
        .difficulty.advanced { background-color: #F44336; color: white; }
        
        #legend { position: absolute; bottom: clamp(10px, 2vh, 20px); left: clamp(10px, 2vw, 20px); background: rgba(40, 40, 60, 0.9); border: 1px solid #9a9ac8; border-radius: 8px; padding: clamp(10px, 2vw, 15px); font-size: clamp(10px, 2.5vw, 12px); color: #e0e0e0; max-width: clamp(150px, 35vw, 200px); backdrop-filter: blur(5px); z-index: 20; }
        #legend h4 { margin: 0 0 8px 0; color: #ffffff; font-size: clamp(12px, 3vw, 14px); }
        #legend .legend-size-demo { display: flex; align-items: center; gap: 4px; margin: 6px 0; }
        #legend .size-circle { border-radius: 50%; }

        .spectrum-bubble .remove-btn { font-size: 18px; fill: #ffca85; cursor: pointer; text-anchor: middle; dominant-baseline: middle; opacity: 0; transition: opacity 0.2s; }
        .spectrum-bubble:hover .remove-btn { opacity: 1; }
        .spectrum-bubble.dragging { cursor: grabbing; }
        
        #add-word-container { position: absolute; bottom: clamp(10px, 2vh, 20px); left: 50%; transform: translateX(-50%); display: flex; gap: 10px; background: rgba(40, 40, 60, 0.9); padding: 10px 15px; border-radius: 8px; border: 1px solid #9a9ac8; backdrop-filter: blur(5px); z-index: 100; }
        #add-word-input { background: rgba(255, 255, 255, 0.1); border: 1px solid #7a7a9f; border-radius: 5px; color: white; font-size: 14px; padding: 8px 12px; outline: none; }
        #add-word-btn { background-color: #FF6B47; border: none; color: #1a1a2e; font-weight: bold; border-radius: 5px; padding: 8px 16px; cursor: pointer; transition: background-color 0.2s; }
        #add-word-btn:hover { background-color: #ffca85; }
        #add-word-btn:disabled { background-color: #555; cursor: not-allowed; }

        .spectrum-y-axis-label { fill: #9a9ac8; font-size: 10px; text-transform: uppercase; font-style: italic; }    
    </style>
</head>
<body>
    <img src="https://eltcation.com/wp-content/uploads/2025/06/ELTcation_left.png" alt="ELTcation Logo" class="header-logo">
    
    <div id="top-right-controls">
        <div id="sound-toggle" class="control-btn">
             <!-- ... (SVG code unchanged) ... -->
        </div>
        <div id="export-btn" class="control-btn hidden">
             <!-- ... (SVG code unchanged) ... -->
        </div>
        <div id="restart-btn" class="control-btn hidden">
             <!-- ... (SVG code unchanged) ... -->
        </div>
    </div>

    <h1 id="main-title">Enter a word to build its Radar</h1>
    <div id="chart-container">
        <div id="input-container">
            <form id="word-form">
                <input type="text" id="word-input" placeholder="e.g., see" autocomplete="off">
            </form>
            <div id="pos-selector">
                <div class="pos-option" data-pos="verb">Verb</div>
                <div class="pos-option" data-pos="noun">Noun</div>
                <div class="pos-option" data-pos="adjective">Adjective</div>
            </div>
            <textarea id="custom-words-input" placeholder="Custom Words: Paste comma-separated words to classify instead of using the thesaurus."></textarea>
            <button id="submit-btn" class="hidden">Start</button>
        </div>
        <div id="sense-selector" class="hidden">
            <h3 id="sense-title">Which meaning of "word"?</h3>
            <div id="sense-options"></div>
        </div>
        <div id="radar-scanner" class="hidden"></div>
        <div id="legend" class="hidden">
             <!-- ... (Legend HTML unchanged) ... -->
        </div>
        
        <div id="add-word-container" class="hidden">
            <input type="text" id="add-word-input" placeholder="Add a word...">
            <button id="add-word-btn">Add</button>    
        </div>
        <div class="tooltip"></div>
    </div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    // --- D3 Selections & Initial Setup ---
    const mainTitle = d3.select("#main-title");
    const inputContainer = d3.select("#input-container");
    const wordForm = d3.select("#word-form");
    const scanner = d3.select("#radar-scanner");
    const tooltip = d3.select(".tooltip");
    const legend = d3.select("#legend");
    const senseSelector = d3.select("#sense-selector");
    const restartBtn = d3.select("#restart-btn");
    const exportBtn = d3.select("#export-btn");
    const addWordContainer = d3.select("#add-word-container");
    const addWordInput = d3.select("#add-word-input");
    const addWordBtn = d3.select("#add-word-btn");
    const submitBtn = d3.select("#submit-btn");

    const container = d3.select("#chart-container");
    const containerRect = container.node().getBoundingClientRect();
    const width = containerRect.width;
    const height = containerRect.height;
    
    const isMobile = window.innerWidth <= 768;
    const margin = isMobile ? 65 : 100;
    const maxRadius = (Math.min(width, height) / 2) - margin;

    const svg = container.append("svg").attr("width", width).attr("height", height).attr("viewBox", `0 0 ${width} ${height}`).attr("preserveAspectRatio", "xMidYMid meet")
        .on("click", (event) => {
            if (selectedWords.length > 0) { clearComparison(); } 
            else if (currentView !== 'radar') { event.stopPropagation(); switchToRadarView(); }
        });

    const chartGroup = svg.append("g").attr("transform", `translate(${width / 2}, ${height / 2})`);

    // --- State Variables ---
    let currentView = 'radar', activeSpectrum = null, currentBubbles = null, currentAntonymBubbles = null, selectedWords = [], isSoundOn = true;
    let currentRadarData = null, currentSpectrumData = null;
    let currentSearch = { word: '', partOfSpeech: '' };

    // --- Scales & Colors ---
    const bubbleSizeScale = d3.scaleSqrt().domain([0, 100]).range(isMobile ? [5, 20] : [8, 30]);
    const difficultyColors = { beginner: '#4CAF50', intermediate: '#FF9800', advanced: '#F44336' };
    
    const radarXScale = d3.scaleLinear().domain([-1.1, 1.1]).range([-maxRadius + bubbleSizeScale.range()[1], maxRadius - bubbleSizeScale.range()[1]]);
    const radarYScale = d3.scaleLinear().domain([-1.1, 1.1]).range([maxRadius - bubbleSizeScale.range()[1], -maxRadius + bubbleSizeScale.range()[1]]);

    const spectrumRangeX = maxRadius * 0.8;
    const spectrumRangeY = maxRadius * 0.5;
    const spectrumScale = d3.scaleLinear().domain([-1.1, 1.1]).range([-spectrumRangeX, spectrumRangeX]).clamp(true);
    const spectrumYScale = d3.scaleLinear().domain([-1.1, 1.1]).range([spectrumRangeY, -spectrumRangeY]).clamp(true);

    // --- SVG Groups ---
    const radarBgGroup = chartGroup.append("g").attr("class", "radar-background");
    const spectrumGroup = chartGroup.append("g").attr("class", "spectrum-view").style("opacity", 0).attr("pointer-events", "none");
    const bubblesGroup = chartGroup.append("g").attr("class", "bubbles-container");
    const antonymsGroup = chartGroup.append("g").attr("class", "antonyms-container");
    const labelsGroup = chartGroup.append("g").attr("class", "labels-container");
    
    // --- All Functions (collapsed for brevity, full code below) ---
    function updateSubmitButtonState() { /* ... */ }
    async function handleFormSubmit(event) { /* ... */ }
    async function handleSenseSelection(synonyms) { /* ... */ }
    function getMetadataHTML(d) { /* ... */ }
    function handleWordClick(event, d) { /* ... */ }
    function clearComparison() { /* ... */ }
    function showComparisonTooltip(d1, d2) { /* ... */ }
    function speak(text, lang = 'en-US') { /* ... */ }
    function setupTooltipEvents(selection) { /* ... */ }
    function exportAsPNG() { /* ... */ }
    async function fetchWordData(payload) { /* ... */ }
    function setupSoundToggle() { /* ... */ }
    function resetToInitialState() { /* ... */ }
    function drawRadarBackground() { /* ... */ }
    function drawSpectrumView() { /* ... */ }
    async function handleAddWord() { /* ... */ }
    function updateSpectrumView(nodes) { /* ... */ }
    function drawWordBubbles(radarData) { /* ... */ }
    function clearChart() { /* ... */ }
    async function handleAxisClick(event, d) { /* ... */ }
    async function handleAntonymClick(event, d) { /* ... */ }
    function switchToSpectrumView(spectrumData) { /* ... */ }
    function switchToRadarView() { /* ... */ }
    function updateLegend(data) { /* ... */ }

    // --- Function Implementations ---
    
    updateSubmitButtonState = function() {
        const word = d3.select("#word-input").property("value").trim();
        const posSelected = d3.select(".pos-option.selected").node();
        submitBtn.classed("hidden", !(word && posSelected));
    };

    handleFormSubmit = async function(event) {
        event.preventDefault();
        currentSearch.word = d3.select("#word-input").property("value").trim();
        const selectedPosNode = d3.select(".pos-option.selected").node();
        const customWords = d3.select("#custom-words-input").property("value").trim();

        if (!currentSearch.word || !selectedPosNode) return;
        currentSearch.partOfSpeech = selectedPosNode.dataset.pos;
        
        if (currentView !== 'radar') await switchToRadarView();

        inputContainer.classed("hidden", true);
        legend.classed("hidden", true);
        clearChart();

        if (customWords) {
            const synonyms = customWords.split(',').map(s => s.trim()).filter(Boolean);
            if (synonyms.length > 0) { handleSenseSelection(synonyms); return; }
        }
        
        mainTitle.style("cursor", "default").text(`Discovering meanings for "${currentSearch.word}"...`);
        scanner.classed("hidden", false);
        const discoveryData = await fetchWordData({ word: currentSearch.word, partOfSpeech: currentSearch.partOfSpeech });
        scanner.classed("hidden", true);

        if (discoveryData && discoveryData.senses) {
            mainTitle.text("Please select a meaning to explore");
            senseSelector.select("#sense-title").text(`Which meaning of "${currentSearch.word}"?`);
            senseSelector.select("#sense-options").html(""); // Clear previous options
            
            const options = senseSelector.select("#sense-options").selectAll("button").data(discoveryData.senses);
            options.enter().append("button")
                .attr("class", "sense-option-btn")
                .html(d => `"${d.synonyms.slice(0, 3).join('", "')}" ${d.synonyms.length > 3 ? `(+${d.synonyms.length - 3})` : ''} — <i>${d.definition}</i>`)
                .on("click", (e, d) => handleSenseSelection(d.synonyms));
            senseSelector.classed("hidden", false);

        } else if (discoveryData && discoveryData.words) {
            handleSenseSelection(null, discoveryData);
        } else {
            mainTitle.text(discoveryData.error || `No data for "${currentSearch.word}". Click to try again.`).style("cursor", "pointer");
            restartBtn.classed("hidden", false);
        }
    };
    
    handleSenseSelection = async function(synonyms, preloadedData = null) {
        senseSelector.classed("hidden", true);
        
        let wordData;
        if (preloadedData) {
            wordData = preloadedData;
        } else {
            mainTitle.style("cursor", "default").text(`Generating Radar for "${currentSearch.word}"...`);
            scanner.classed("hidden", false);
            wordData = await fetchWordData({ word: currentSearch.word, partOfSpeech: currentSearch.partOfSpeech, synonyms: synonyms });
            scanner.classed("hidden", true);
        }
        
        currentRadarData = wordData;
        if (wordData && wordData.words) {
            mainTitle.text(`Word Radar: "${wordData.hub_word}"`).style("cursor", "pointer");
            drawWordBubbles(wordData);
            legend.classed("hidden", false);
            restartBtn.classed("hidden", false);
            exportBtn.classed("hidden", false);
        } else {
            mainTitle.text(wordData.error || `Failed to generate radar. Click to try again.`).style("cursor", "pointer");
            restartBtn.classed("hidden", false);
        }
    };

    getMetadataHTML = function(d) { /* ... (implementation unchanged from initial version) ... */ return ''; };
    handleWordClick = function(event, d) { /* ... (implementation unchanged from initial version) ... */ };
    clearComparison = function() { /* ... (implementation unchanged from initial version) ... */ };
    showComparisonTooltip = function(d1, d2) { /* ... (implementation unchanged from initial version) ... */ };
    speak = function(text, lang = 'en-US') { if ('speechSynthesis' in window && isSoundOn) { window.speechSynthesis.cancel(); const u = new SpeechSynthesisUtterance(text); u.lang = lang; window.speechSynthesis.speak(u); } };
    setupTooltipEvents = function(selection) { /* ... (implementation unchanged from initial version) ... */ };
    exportAsPNG = function() { /* ... (implementation unchanged from initial version) ... */ };
    
    fetchWordData = async function(payload) {
        try {
            const response = await fetch('/.netlify/functions/word-radar-data', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `Server Error: ${response.status}`);
            }
            return await response.json();
        } catch (error) {
            console.error("Failed to fetch word data:", error);
            return { error: error.message };
        }
    };
    
    setupSoundToggle = function() { /* ... (implementation unchanged from initial version) ... */ };

    resetToInitialState = function() {
        if (!scanner.classed("hidden")) return;
        switchToRadarView().then(() => {
            clearChart();
            mainTitle.text("Enter a word to build its Radar").style("cursor", "default");
            inputContainer.classed("hidden", false);
            senseSelector.classed("hidden", true);
            legend.classed("hidden", true);
            restartBtn.classed("hidden", true);
            exportBtn.classed("hidden", true);
            addWordContainer.classed("hidden", true);
            d3.select("#word-input").property("value", "").node().focus();
            d3.select("#custom-words-input").property("value", "");
            d3.selectAll('.pos-option').classed('selected', false);
            submitBtn.classed("hidden", true);
            currentRadarData = null;
            currentSpectrumData = null;
        });
    };

    drawRadarBackground = function() { /* ... (implementation unchanged from initial version) ... */ };
    drawSpectrumView = function() {
        spectrumGroup.selectAll("*").remove();
        spectrumGroup.append("line").attr("class", "spectrum-axis spectrum-axis-x").attr("x1", -spectrumRangeX).attr("x2", spectrumRangeX);
        spectrumGroup.append("line").attr("class", "spectrum-axis spectrum-axis-y").attr("y1", -spectrumRangeY).attr("y2", spectrumRangeY);
        spectrumGroup.append("text").attr("class", "spectrum-label spectrum-label-left").attr("x", -spectrumRangeX - 15).attr("text-anchor", "end").attr("dominant-baseline", "middle");
        spectrumGroup.append("text").attr("class", "spectrum-label spectrum-label-right").attr("x", spectrumRangeX + 15).attr("text-anchor", "start").attr("dominant-baseline", "middle");
        spectrumGroup.append("text").attr("class", "spectrum-y-axis-label").attr("y", -spectrumRangeY - 10).attr("text-anchor", "middle").text("More Formal");
        spectrumGroup.append("text").attr("class", "spectrum-y-axis-label").attr("y", spectrumRangeY + 20).attr("text-anchor", "middle").text("Less Formal");
    };

    handleAddWord = async function() {
        const newWord = addWordInput.property("value").trim();
        if (!newWord || !currentSpectrumData) return;
        addWordBtn.attr("disabled", true).text("Adding...");
        
        const payload = { ...currentSpectrumData.request_params, new_word: newWord };
        const result = await fetchWordData(payload);

        if (result && result.words) {
            currentSpectrumData.words = result.words;
            updateSpectrumView(currentSpectrumData.words);
            addWordInput.property("value", "");
        } else {
            alert(result.error || `Could not add "${newWord}".`);
        }
        addWordBtn.attr("disabled", null).text("Add");
    };

    updateSpectrumView = function(nodes) {
        const drag = d3.drag()
            .on("start", (event, d) => { d3.select(event.sourceEvent.target.parentNode).raise().classed("dragging", true); })
            .on("drag", (event, d) => {
                d.x = spectrumScale.invert(spectrumScale(d.x) + event.dx);
                d.y = spectrumYScale.invert(spectrumYScale(d.y) + event.dy);
                d3.select(event.sourceEvent.target.parentNode).attr("transform", `translate(${spectrumScale(d.x)},${spectrumYScale(d.y)})`);
            })
            .on("end", (event, d) => { d3.select(event.sourceEvent.target.parentNode).classed("dragging", false); });

        const simulation = d3.forceSimulation(nodes)
            .force("x", d3.forceX(d => spectrumScale(d.spectrum_position)).strength(1))
            .force("y", d3.forceY(d => spectrumYScale(d.formality)).strength(1))
            .force("collide", d3.forceCollide(d => bubbleSizeScale(d.frequency) + 3).strength(0.7))
            .stop();
        for (let i = 0; i < 150; ++i) simulation.tick();
        
        const bubbleJoin = bubblesGroup.selectAll(".spectrum-bubble").data(nodes, d => d.term);
        bubbleJoin.exit().transition().duration(300).attr("transform", "translate(0,0)").style("opacity", 0).remove();
        
        const enterGroup = bubbleJoin.enter().append("g").attr("class", "word-bubble spectrum-bubble");
        enterGroup.append("circle").attr("r", d => bubbleSizeScale(d.frequency)).style("fill", d => difficultyColors[d.difficulty] || '#1f77b4');
        enterGroup.append("text").attr("class", "word-text").text(d => d.term).attr("dy", "0.3em");
        enterGroup.append("text").attr("class", "remove-btn").text("×").attr("y", d => -bubbleSizeScale(d.frequency) - 5)
            .on("click", (e, d) => {
                e.stopPropagation();
                currentSpectrumData.words = currentSpectrumData.words.filter(w => w.term !== d.term);
                updateSpectrumView(currentSpectrumData.words);
            });
        
        const allBubbles = enterGroup.merge(bubbleJoin);
        allBubbles.transition().duration(750).ease(d3.easeCubicOut)
            .attr("transform", d => `translate(${d.x}, ${d.y})`);
            
        allBubbles.call(drag);
        setupTooltipEvents(allBubbles);
    };

    drawWordBubbles = function(radarData) {
        clearChart();
        const labelOffset = maxRadius + (isMobile ? 15 : 25);
        const axisLabels = [
            { text: 'FORMAL', x: 0, y: -labelOffset, anchor: 'middle', type: 'formality' },
            { text: 'FIGURATIVE', x: labelOffset, y: 0, anchor: 'start', type: 'style' },
            { text: 'INFORMAL', x: 0, y: labelOffset, anchor: 'middle', type: 'formality' },
            { text: 'LITERAL', x: -labelOffset, y: 0, anchor: 'end', type: 'style' }
        ];

        labelsGroup.selectAll(".axis-label").data(axisLabels).enter().append("text")
            .attr("class", "axis-label").attr("x", d => d.x).attr("y", d => d.y)
            .attr("text-anchor", d => d.anchor).attr("dominant-baseline", "middle")
            .text(d => d.text).on("click", handleAxisClick);

        const nodes = radarData.words.map(d => ({...d, radarX: radarXScale(d.style), radarY: radarYScale(d.formality) }));
        const simulation = d3.forceSimulation(nodes)
            .force("collide", d3.forceCollide(d => bubbleSizeScale(d.frequency) + 4).strength(1))
            .force("x", d3.forceX(d => d.radarX).strength(0.1))
            .force("y", d3.forceY(d => d.radarY).strength(0.1))
            .stop();
        for (let i = 0; i < 300; ++i) simulation.tick();
        
        currentBubbles = bubblesGroup.selectAll(".word-bubble").data(nodes, d => d.term)
            .enter().append("g").attr("class", "word-bubble");
        currentBubbles.append("circle").attr("r", 0).style("fill", d => difficultyColors[d.difficulty] || '#1f77b4')
            .transition().duration(500).delay((d,i) => i * 20).attr("r", d => bubbleSizeScale(d.frequency));
        currentBubbles.append("text").text(d => d.term).attr("dy", "0.3em").style("opacity", 0)
            .transition().duration(500).delay((d,i) => i * 20).style("opacity", 1);
        currentBubbles.attr("transform", d => `translate(${d.x}, ${d.y})`);
        setupTooltipEvents(currentBubbles);

        const antonymNodes = radarData.antonyms.map(ant => ({ term: ant }));
        currentAntonymBubbles = antonymsGroup.selectAll(".antonym-bubble").data(antonymNodes, d => d.term)
            .enter().append("g").attr("class", "word-bubble antonym-bubble").on("click", handleAntonymClick);
        // ... (rest of antonym drawing logic is fine)
    };

    clearChart = function() {
        clearComparison();
        bubblesGroup.selectAll("*").remove();
        antonymsGroup.selectAll("*").remove();
        labelsGroup.selectAll(".axis-label").remove();
        currentBubbles = null;
        currentAntonymBubbles = null;
    };
    
    handleAxisClick = async function(event, d) {
        event.stopPropagation();
        mainTitle.text(`Generating spectrum for ${d.type}...`);
        scanner.classed("hidden", false);
        const spectrumData = await fetchWordData({ ...currentRadarData.request_params, spectrum_type: d.type });
        scanner.classed("hidden", true);
        if (spectrumData && spectrumData.words) {
            switchToSpectrumView(spectrumData);
        } else { mainTitle.text(spectrumData.error || "Could not generate spectrum."); }
    };
    
    handleAntonymClick = async function(event, d) {
        event.stopPropagation();
        mainTitle.text(`Generating spectrum for "${currentRadarData.hub_word}" vs "${d.term}"...`);
        scanner.classed("hidden", false);
        const spectrumData = await fetchWordData({ ...currentRadarData.request_params, antonym: d.term });
        scanner.classed("hidden", true);
        if (spectrumData && spectrumData.words) {
            switchToSpectrumView(spectrumData);
        } else { mainTitle.text(spectrumData.error || "Could not generate spectrum."); }
    };

    switchToSpectrumView = function(spectrumData) {
        clearComparison();
        currentView = 'spectrum';
        currentSpectrumData = spectrumData;

        mainTitle.text(`Spectrum: "${spectrumData.start_word}" vs "${spectrumData.end_word}"`);
        spectrumGroup.select(".spectrum-label-left").text(spectrumData.start_word.toUpperCase());
        spectrumGroup.select(".spectrum-label-right").text(spectrumData.end_word.toUpperCase());

        radarBgGroup.transition().duration(500).style("opacity", 0);
        labelsGroup.transition().duration(500).style("opacity", 0).attr("pointer-events", "none");
        antonymsGroup.transition().duration(500).style("opacity", 0).attr("pointer-events", "none");
        if (currentBubbles) currentBubbles.transition().duration(500).style("opacity", 0).attr("pointer-events", "none");

        spectrumGroup.transition().delay(200).duration(500).style("opacity", 1).attr("pointer-events", "auto");
        addWordContainer.classed("hidden", false);
        
        updateSpectrumView(spectrumData.words);
    };

    switchToRadarView = function() {
        return new Promise(resolve => {
            if (currentView !== 'spectrum') { resolve(); return; }
            clearComparison(); 
            currentView = 'radar';
            currentSpectrumData = null;
            if (currentRadarData) mainTitle.text(`Word Radar: "${currentRadarData.hub_word}"`);

            spectrumGroup.transition().duration(500).style("opacity", 0).attr("pointer-events", "none");
            addWordContainer.classed("hidden", true);
            bubblesGroup.selectAll(".spectrum-bubble").remove();

            radarBgGroup.transition().delay(200).duration(500).style("opacity", 1);
            labelsGroup.transition().delay(200).duration(500).style("opacity", 1).attr("pointer-events", "auto");
            antonymsGroup.transition().delay(200).duration(500).style("opacity", 1).attr("pointer-events", "auto");

            if (currentBubbles) {
                const nodes = currentBubbles.data();
                const simulation = d3.forceSimulation(nodes)
                    .force("collide", d3.forceCollide(d => bubbleSizeScale(d.frequency) + 3).strength(0.8))
                    .force("x", d3.forceX(d => d.radarX).strength(0.1))
                    .force("y", d3.forceY(d => d.radarY).strength(0.1))
                    .stop();
                for (let i = 0; i < 200; ++i) simulation.tick();
                
                currentBubbles.transition().duration(750).ease(d3.easeCubicOut)
                    .style("opacity", 1).attr("pointer-events", "auto")
                    .attr("transform", d => `translate(${d.x}, ${d.y})`)
                    .end().then(resolve);
            } else { resolve(); }
        });
    };

    updateLegend = function(data) { /* ... (implementation unchanged) ... */ };

    // --- Event Listeners & Initial Calls ---
    submitBtn.on("click", handleFormSubmit);
    wordForm.on("submit", handleFormSubmit);
    d3.select('#word-input').on('input', updateSubmitButtonState);
    d3.selectAll('.pos-option').on('click', function() {
        d3.selectAll('.pos-option').classed('selected', false);
        d3.select(this).classed('selected', true);
        updateSubmitButtonState();
    });
    mainTitle.on("click", resetToInitialState);
    restartBtn.on("click", resetToInitialState);
    exportBtn.on("click", exportAsPNG);
    addWordBtn.on("click", handleAddWord);
    addWordInput.on("keydown", (event) => { if (event.key === 'Enter') { event.preventDefault(); handleAddWord(); } });
    setupSoundToggle();
    drawRadarBackground();
    drawSpectrumView();
});
</script>
</body>
</html>